#include <stdio.h>
#include "common.h"

// 1. 지역변수
// 2. 전역변수
// 3. 정적변수(static)
// 4. 외부변수(extern)

// 메모리 영역
// 1. 스택 영역 : 함수가 사용하는 영역
// 2. 데이터 영역 
// 3. 읽기 전용(코드, ReadOnlyMemory)
// 4. 힙 영역

// 전역변수
int g_i = 0;
// Data 영역 특징
// 프로그램 시작과 동시에 자리를 차지한다.
// 프로그램 종료 시 해제

// 헤더와 소스파일의 분할 구현

#include "function.h"

// 정적변수의 특징
// 키워드 static
// 전역변수와 정적변수의 차이점
// 다른 파일에서 전역변수를 선언했을 때 컴파일 단계에서는 문제가 없다.
// 단, 링크 과정에서 두개의 전역 변수가 선언되서 에러가 발생한다.
// 정적변수는 선언되는 위치에 따라 차이가 있지만,
// static 키워드의 공통적인 의미
// 해당 위치에 박혀 있다. cpp 파일에 선언되어 해당 위치에서만 찾을 수 있다.
static int g_iStatic = 0;
int g_iExtern = 0;

void Test2() {
	static int i = 0; // Test가 호출될 때 마다 그 데이터를 넣겠다는 의미가 아니다. 초기값을 0으로 넣는다는 의미이며, 다음부터는 문법적으로 넘어가는 조건문이 선언되있다. 컴파일러가 해당 역할을 한다.
	// Test2 함수 안에 틀어 박혀 있는 정수형 데이터 타입 변수 i
	// 데이터 영역을 쓰는 변수이지만, 해당 함수 안에서만 사용할 수 있다.
	// 단, 해당 함수가 종료되어도 데이터 영역에 남아 있다.
	// 그러면, Test2를 반복시켜서 해당 데이터를 증가 시킬 수 있겠네?
	// 전역 변수와의 차이점? 상시 유지시키는 점에서는 전역 변수와 같다.
	// 정적 변수는 다른 곳에서 못쓴다. 즉, 제한을 거는 것이다.
	// 프로그래머의 실수를 방지할 수 있도록 제한을 거는 것으로 이해.
	// 다른 함수에서 접근하는 것을 방지할 수 없다.
	// 따라서 내가 만든 함수 안에서만 작동하도록 만들기 위해서 정적변수를 선언하는 것이다.
}

void Test() {
	int i = 0;
	++i;
}

int main() {
	// 지역변수
	g_iExtern = 500;
	Add(2, 5);
	Sub(3, 1);
	Mul(2, 5);

	// 문자의 정체가 뭘까?
	// 포인터를 설명하기 전 

	// Vstdio - solution 생성 - 프로젝트 - 헤더, cpp
	// 플랫폼이 뭘까?
	// 프로그래머 적으로 플랫폼? 
	// 무엇인가를 실행하기 위한 기반이다.
	// 윈도우라는 플랫폼 위에 스팀, 에픽 게임즈.. 등의 플랫폼이 있다.
	// 윈도우 운영체제가 32비트와 64비트 두개로 나뉘어 있다.
	// 데이터 처리 단위가 작아지면 메모리 문제가 생긴다.(게임들의 사양이 높아지기 때문에)
	// OS의 데이터 처리 단위를 알려면 포인터에 대해서 알아야 한다.

	// 포인터 변수
	// 주소를 저장하는 기능 을 수행하는 변수

	int i = 100;
	float f = 3.f;
	int* tint = (int*) & f; // 컴파일러는 문법적으로 봤을 때 int 주소를 받는 곳에는 int값을 넣는게 맞는대 float 받을려고 하니 막을랫는대, 프로그래머가 강제로 하겠다고 한거..

	int* kint = &i;
	int* pInt = nullptr; // nullptr : 아무것도 없다고 표기하는것. 실제로 들어가는 값은 0
	// *이 붙는 순간 int 포인트 변수가 되었다.
	// int 자료형을 저장하는 변수이다.



	// 주소가 무슨 개념일까?
	// 메모리의 위치를 표현하는 개념
	// 주소를 알면 포인트 변수를 이용해서 값을 바꿀수 있다.
	// 주소로 접근하는 기능
	*kint = 100; // 포인트 변수가 저장하고 있는 변수에 값을 넣어라.

	// 주소의 단위 ( 주소 1차이 날때 마다 얼마나 차이가 날까?) : byte이며 정수 표현 방식이다.
	// 주소의 단위보다 작은 bit에도 주소를 넣을 수 있을까? 없다.
	// 포인터 변수를 선언할 때 어디 주소에 어떤 데이터가 있는 지 미리 선언하는 것이다. 주소 변수는 따로 있고, 선언한 데이터를 미리 선언한 것.
	// 컴퓨터 비트에 들어 있는 숫자는 같은대, 데이터 타입을 보는 관점에 따라서 실제 값이 다르게 나온다. 이 개념이 앞으로 중요할 것이다.
	100;

	105;

	return 0;
}